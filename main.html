<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Perfect Shape - Mobile Fixed</title>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.css');

        /* 모바일 전체 화면 고정 및 배경색 강제 */
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background-color: #000; 
            touch-action: none; /* 모바일 드래그 시 브라우저 새로고침 방지 */
        }

        body { 
            cursor: grab; font-family: 'Pretendard', sans-serif; 
            -webkit-font-smoothing: antialiased;
        }

        canvas { 
            position: absolute; top: 0; left: 0; 
            display: block; background-color: #000;
            filter: contrast(130%) brightness(110%); 
        }

        /* [정중앙] 메시지 - 모바일 대응 폰트 크기 */
        #message-ui {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; text-align: center; pointer-events: none; z-index: 10;
            letter-spacing: -0.02em; width: 90%; opacity: 0.8;
            animation: text-resonance 4s infinite ease-in-out;
        }
        #message-ui h1 { font-size: clamp(16px, 5vw, 24px); margin: 0 0 10px 0; font-weight: 800; line-height: 1.4; }
        #message-ui p { font-size: clamp(11px, 3vw, 14px); margin: 0; opacity: 0.5; font-weight: 300; }

        @keyframes text-resonance {
            0%, 100% { opacity: 0.5; text-shadow: 0 0 8px rgba(255, 255, 255, 0.1); }
            50% { opacity: 1; text-shadow: 0 0 25px rgba(255, 255, 255, 0.5); }
        }

        /* [상단 오른쪽] 데이터 스트림 - 모바일에서 크기 축소 */
        #data-stream {
            position: fixed; top: 20px; right: 20px; font-family: 'Courier New', monospace; 
            font-size: 9px; color: rgba(255, 255, 255, 0.2); text-align: right; z-index: 10;
        }
        .data-row { display: flex; justify-content: flex-end; gap: 8px; margin-bottom: 4px; }
        .data-value { color: rgba(255, 255, 255, 0.4); width: 60px; text-align: left; }
    </style>
</head>
<body>
    <div id="message-ui">
        <h1>"가장 완벽한 도형 안에 갇힌 것을 환영합니다."</h1>
        <p id="sub-msg">화면을 터치하면 공간의 소리가 깨어납니다.</p>
    </div>

    <div id="data-stream">
        <div class="data-row"><span>SYNC_D</span> <span id="delta-val" class="data-value">0.0000</span></div>
        <div class="data-row"><span>VAR_I</span> <span id="var-val" class="data-value">1.0000</span></div>
        <div class="data-row"><span>AUDIO</span> <span id="freq-val" class="data-value">OFF</span></div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // --- [1] Web Audio API ---
        let audioCtx;
        function initSound() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const frequencies = [55, 82.4, 110]; 
            frequencies.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const lfo = audioCtx.createOscillator();
                const lfoGain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                osc.type = i === 1 ? 'triangle' : 'sine';
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                filter.type = 'lowpass';
                filter.frequency.value = 150 + (i * 100);
                gain.gain.value = 0;
                lfo.frequency.value = 0.1 + (i * 0.05);
                lfoGain.gain.value = 0.04; 
                
                lfo.connect(lfoGain);
                lfoGain.connect(gain.gain);
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start();
                lfo.start();
                gain.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime + 3);
            });
            document.getElementById('sub-msg').innerText = "그저 바라보기만 하십시오.";
        }

        // --- [2] 비주얼 엔진 ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let width, height, baseSize, time = 0;
        let cameraZ = 2000, targetCameraZ = 2000;
        let rotY = 0, targetRotY = 0, rotX = 0, targetRotX = 0;
        let isDragging = false, lastX = 0, lastY = 0;
        
        let vertices = [], edges = [[0, 1], [0, 2], [0, 3], [1, 2], [2, 3], [3, 1]];
        const particles = [], particleCount = window.innerWidth < 600 ? 150 : 450; // 모바일 입자 수 최적화
        const glowCanvas = document.createElement('canvas');
        const gCtx = glowCanvas.getContext('2d');

        function preRenderGlow() {
            const size = 512; // 모바일 성능을 위해 사이즈 축소
            glowCanvas.width = size; glowCanvas.height = size;
            const grad = gCtx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.1, 'rgba(255, 255, 255, 0.15)');
            grad.addColorStop(0.4, 'rgba(255, 255, 255, 0.01)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            gCtx.fillStyle = grad; gCtx.fillRect(0, 0, size, size);
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            // 모바일에서 너무 커지지 않도록 baseSize 조정
            baseSize = Math.min(width, height) * 1.5; 
            const s = baseSize * 0.8;
            vertices = [
                {x: 0, y: -s, z: 0}, {x: s * Math.sqrt(8/9), y: s/3, z: 0},
                {x: -s * Math.sqrt(2/9), y: s/3, z: s * Math.sqrt(2/3)},
                {x: -s * Math.sqrt(2/9), y: s/3, z: -s * Math.sqrt(2/3)}
            ];
            particles.length = 0;
            for(let i=0; i<particleCount; i++) {
                particles.push({
                    x: (Math.random() - 0.5) * width * 4,
                    y: (Math.random() - 0.5) * height * 4,
                    z: (Math.random() - 0.5) * 4000,
                    size: Math.random() * 2 + 0.5
                });
            }
            preRenderGlow();
        }

        // 마우스 & 터치 이벤트 통합
        function start(x, y) {
            initSound();
            isDragging = true;
            lastX = x; lastY = y;
        }
        function move(x, y) {
            if (!isDragging) return;
            targetRotY += (x - lastX) * 0.005;
            targetRotX += (y - lastY) * 0.005;
            targetRotX = Math.max(-0.8, Math.min(0.8, targetRotX));
            lastX = x; lastY = y;
        }

        window.addEventListener('mousedown', e => start(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
        window.addEventListener('mouseup', () => isDragging = false);

        window.addEventListener('touchstart', e => start(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
        window.addEventListener('touchmove', e => move(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
        window.addEventListener('touchend', () => isDragging = false);

        window.addEventListener('resize', resize);
        resize();

        function rotate3D(v, angleX, angleY) {
            let cosY = Math.cos(angleY), sinY = Math.sin(angleY);
            let x1 = v.x * cosY - v.z * sinY, z1 = v.x * sinY + v.z * cosY;
            let cosX = Math.cos(angleX), sinX = Math.sin(angleX);
            return { x: x1, y: v.y * cosX - z1 * sinX, z: v.y * sinX + z1 * cosX };
        }

        function project(v) {
            cameraZ += (targetCameraZ - cameraZ) * 0.05;
            rotY += (targetRotY - rotY) * 0.05; 
            rotX += (targetRotX - rotX) * 0.05;
            const perspective = 1000;
            const scale = perspective / (perspective + v.z + cameraZ);
            return { x: v.x * scale + width * 0.5, y: v.y * scale + height * 0.5, scale: scale };
        }

        const deltaEl = document.getElementById('delta-val');
        const varEl = document.getElementById('var-val');
        const freqEl = document.getElementById('freq-val');

        function draw() {
            time += 0.003; 
            const breath = 1 + Math.sin(time * 2.5) * 0.15;
            
            deltaEl.innerText = (Math.random() * 0.004).toFixed(4);
            varEl.innerText = (breath).toFixed(4);
            freqEl.innerText = audioCtx ? (breath > 1 ? "HIGH" : "LOW") : "OFF";

            // 매 프레임 검정색으로 강제 초기화 (흰 화면 방지)
            ctx.fillStyle = '#000'; 
            ctx.fillRect(0, 0, width, height);

            const currentRotX = rotX + Math.sin(time * 0.3) * 0.1;
            const currentRotY = rotY + time * 0.1;

            // 입자
            particles.forEach(p => {
                const rotated = rotate3D(p, currentRotX, currentRotY);
                const proj = project(rotated);
                if (proj.scale > 0) {
                    ctx.globalAlpha = Math.min(0.6, proj.scale * 1.2);
                    ctx.fillStyle = "white";
                    ctx.beginPath(); ctx.arc(proj.x, proj.y, p.size * proj.scale, 0, Math.PI * 2); ctx.fill();
                }
            });

            ctx.globalAlpha = 1;
            const proj = vertices.map(v => project(rotate3D(v, currentRotX, currentRotY)));
            
            // 광원 효과
            edges.forEach(edge => {
                const p1 = proj[edge[0]], p2 = proj[edge[1]];
                const dist = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
                const steps = Math.min(dist / 1.5, 100); 
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (let i = 0; i <= steps; i++) {
                    const ratio = i / steps;
                    const x = p1.x + (p2.x - p1.x) * ratio;
                    const y = p1.y + (p2.y - p1.y) * ratio;
                    const s = (width < 600 ? 600 : 1200) * ((p1.scale + p2.scale)/2) * breath; 
                    ctx.drawImage(glowCanvas, x - s/2, y - s/2, s, s);
                }
                ctx.restore();
            });

            // 선
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            edges.forEach(edge => {
                const p1 = proj[edge[0]], p2 = proj[edge[1]];
                ctx.beginPath();
                ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(0.4, p1.scale) * breath})`;
                ctx.lineWidth = 1 * breath;
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            });
            ctx.restore();
            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>
