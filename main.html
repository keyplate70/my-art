<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Perfect Shape - Responsive Integrated</title>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.css');
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; cursor: grab; font-family: 'Pretendard', sans-serif; touch-action: none; }
        canvas { position: fixed; top: 0; left: 0; filter: contrast(130%) brightness(110%); }
        
        /* 오리지널 문구 UI */
        #message-ui {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; text-align: center; pointer-events: none; z-index: 10;
            letter-spacing: -0.02em; width: 100%; opacity: 0.8;
            animation: text-resonance 4s infinite ease-in-out;
        }
        #message-ui h1 { font-size: clamp(18px, 2.5vw, 28px); margin: 0 0 10px 0; font-weight: 800; }
        #message-ui p { font-size: clamp(13px, 1.2vw, 16px); margin: 0; opacity: 0.5; font-weight: 300; }
        
        @keyframes text-resonance {
            0%, 100% { opacity: 0.6; text-shadow: 0 0 10px rgba(255, 255, 255, 0.1); }
            50% { opacity: 1; text-shadow: 0 0 30px rgba(255, 255, 255, 0.4); }
        }

        #data-stream {
            position: fixed; top: 50px; right: 50px; font-family: 'Courier New', monospace; 
            font-size: 11px; color: rgba(255, 255, 255, 0.25); text-align: right; z-index: 10;
        }
        .data-row { display: flex; justify-content: flex-end; gap: 12px; margin-bottom: 6px; }
        .data-value { color: rgba(255, 255, 255, 0.45); width: 80px; text-align: left; }
        
        /* 모바일용 레이아웃 미세조정 */
        @media (max-width: 768px) {
            #data-stream { top: 30px; right: 30px; font-size: 10px; }
        }
    </style>
</head>
<body>
    <div id="message-ui">
        <h1>"가장 완벽한 도형 안에 갇힌 것을 환영합니다."</h1>
        <p id="sub-msg">화면을 클릭(터치)하면 공간의 소리가 깨어납니다.</p>
    </div>

    <div id="data-stream">
        <div class="data-row"><span>SYNC_DELTA</span> <span id="delta-val" class="data-value">0.0000</span></div>
        <div class="data-row"><span>VAR_INDEX</span> <span id="var-val" class="data-value">1.0000</span></div>
        <div class="data-row"><span>AUDIO_FRQ</span> <span id="freq-val" class="data-value">LOW</span></div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // --- [1] 사운드 엔진 ---
        let audioCtx;
        function initSound() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const frequencies = [55, 82.4, 110]; 
            frequencies.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                osc.type = i === 1 ? 'triangle' : 'sine';
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                filter.type = 'lowpass';
                filter.frequency.value = 150 + (i * 100);
                gain.gain.value = 0;
                osc.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
                osc.start();
                gain.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 3);
            });
            document.getElementById('sub-msg').innerText = "그저 바라보기만 하십시오.";
        }

        // --- [2] 비주얼 엔진 ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let width, height, baseSize, time = 0;
        
        const getIsMobile = () => window.innerWidth < 768;
        let cameraZ, targetCameraZ, rotY = 0, targetRotY = 0, rotX = 0, targetRotX = 0;
        let isDragging = false, lastX = 0, lastY = 0;

        let vertices = [], edges = [[0, 1], [0, 2], [0, 3], [1, 2], [2, 3], [3, 1]];
        const particles = [];
        const glowCanvas = document.createElement('canvas');
        const gCtx = glowCanvas.getContext('2d');

        function preRenderGlow() {
            const size = 600;
            glowCanvas.width = size; glowCanvas.height = size;
            const grad = gCtx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            // 모바일 환경일 때 광원의 밀도를 더 압축하여 선명하게 표현
            const glowOpacity = getIsMobile() ? 0.6 : 0.8;
            grad.addColorStop(0, `rgba(255, 255, 255, ${glowOpacity})`); 
            grad.addColorStop(0.2, 'rgba(255, 255, 255, 0.12)');
            grad.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
            gCtx.fillStyle = grad; gCtx.fillRect(0, 0, size, size);
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            const isMobile = getIsMobile();
            
            // 환경별 사이즈 비율 분기 (모바일 웅장하게, 웹 시원하게)
            const currentRatio = isMobile ? 3.8 : 7;
            cameraZ = isMobile ? 2400 : 1800;
            targetCameraZ = cameraZ;
            
            baseSize = Math.max(width, height) * currentRatio;
            const s = baseSize * 0.8;
            vertices = [{x: 0, y: -s, z: 0}, {x: s * Math.sqrt(8/9), y: s/3, z: 0}, {x: -s * Math.sqrt(2/9), y: s/3, z: s * Math.sqrt(2/3)}, {x: -s * Math.sqrt(2/9), y: s/3, z: -s * Math.sqrt(2/3)}];
            
            particles.length = 0;
            const pCount = isMobile ? 180 : 450;
            for(let i=0; i<pCount; i++) {
                particles.push({x:(Math.random()-0.5)*baseSize*5, y:(Math.random()-0.5)*baseSize*5, z:(Math.random()-0.5)*baseSize*5, size:Math.random()*1.5});
            }
            preRenderGlow();
        }

        function handleStart(x, y) { initSound(); isDragging = true; lastX = x; lastY = y; }
        function handleMove(x, y) { if (!isDragging) return; targetRotY += (x - lastX) * 0.005; targetRotX += (y - lastY) * 0.005; lastX = x; lastY = y; }

        window.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('touchstart', e => { handleStart(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); }, { passive: false });
        window.addEventListener('touchmove', e => { handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        window.addEventListener('touchend', () => isDragging = false);
        window.addEventListener('wheel', e => { targetCameraZ = Math.max(500, Math.min(targetCameraZ + e.deltaY * 1.5, 15000)); }, { passive: true });
        
        window.addEventListener('resize', resize);
        resize();

        function project(v) {
            cameraZ += (targetCameraZ - cameraZ) * 0.05;
            rotY += (targetRotY - rotY) * 0.02; rotX += (targetRotX - rotX) * 0.02;
            const p = 1200;
            const cosY = Math.cos(rotY + time*0.1), sinY = Math.sin(rotY + time*0.1);
            const cosX = Math.cos(rotX + Math.sin(time*0.3)*0.1), sinX = Math.sin(rotX + Math.sin(time*0.3)*0.1);
            let x1 = v.x * cosY - v.z * sinY, z1 = v.x * sinY + v.z * cosY;
            let y2 = v.y * cosX - z1 * sinX, z2 = v.y * sinX + z1 * cosX;
            const scale = p / (p + z2 + cameraZ);
            return { x: x1 * scale + width * 0.5, y: y2 * scale + height * 0.5, scale: scale };
        }

        function draw() {
            time += 0.003;
            const isMobile = getIsMobile();
            const breath = 1 + Math.sin(time * 2.5) * 0.12;
            document.getElementById('delta-val').innerText = (Math.random() * 0.004).toFixed(4);
            document.getElementById('var-val').innerText = (breath).toFixed(4);
            document.getElementById('freq-val').innerText = breath > 1 ? "HIGH" : "LOW";

            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, width, height);
            particles.forEach(p => {
                const proj = project(p);
                if (proj.scale > 0) {
                    ctx.globalAlpha = Math.min(0.5, proj.scale * 2);
                    ctx.fillStyle = "white";
                    ctx.beginPath(); ctx.arc(proj.x, proj.y, p.size * proj.scale, 0, 7); ctx.fill();
                }
            });

            const proj = vertices.map(v => project(v));
            ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'lighter';
            edges.forEach(edge => {
                const p1 = proj[edge[0]], p2 = proj[edge[1]];
                const dist = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
                const steps = Math.min(dist / 1.2, 150); 
                for (let i = 0; i <= steps; i++) {
                    const ratio = i / steps;
                    const x = p1.x + (p2.x - p1.x) * ratio;
                    const y = p1.y + (p2.y - p1.y) * ratio;
                    // 모바일에서는 광원 입자의 크기를 조절하여 선명도 유지
                    const s = (isMobile ? 800 : 1100) * ((p1.scale + p2.scale)/2) * breath;
                    ctx.drawImage(glowCanvas, x - s/2, y - s/2, s, s);
                }
                ctx.beginPath();
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 * breath})`;
                ctx.lineWidth = 1.0; 
                ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            });
            ctx.globalCompositeOperation = 'source-over';
            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>
